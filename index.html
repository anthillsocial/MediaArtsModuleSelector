<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Module Selector - Permalink Dataset</title>
  <style>
    :root {
      --mod-header-color: #748f94;
      --mod-header-grey: #bbb;
      --mod-title-color: #334549;
      --mod-title-grey: #aaa;
    }
    body { font-family: system-ui,sans-serif; background:#f4f4f9; margin:0; }
    .container { max-width:1100px; margin:0 auto 1.2rem auto; background:#fff; padding:0.7em 0.5em 0.6em 0.5em; border-radius:0.7em; box-shadow:0 1px 8px #0001; }
    .top-bar { display: flex; align-items: center; gap: 1em; margin-bottom: 0.8em;}
    .dataset-select { margin-bottom: 0; }
    select { font-size: 1em; padding: 0.15em 0.5em; }
    .modules-blocks { display:flex; gap:0.7em; margin-bottom:0.7em; align-items:flex-start; }
    .modules-block { background:#f8fafd; padding:0.4em 0.35em 0.2em 0.35em; border-radius:0.4em; box-shadow:0 1px 2px #0001; flex:1 1 0; min-width:180px; }
    .block-title { font-size:0.98em; margin-bottom:0.23em; color:#223366; font-weight:bold; text-align:center; padding-bottom:0.1em; border-bottom:1px solid #dde3f6; margin-top:0; letter-spacing:0.15px;}
    .module-list { display:flex; flex-direction:column; gap:0.32em;}
    .module-card { background:#f6f8fb; border:0.6px solid #dde3f6; border-radius:0.28em; padding:0.10em 0.40em 0.08em 0.40em; cursor:pointer; position:relative; transition:background 0.13s, border-color 0.13s, color 0.09s; font-size:0.95em; min-height:unset; user-select:none; margin-bottom:0.01em; font-weight:500; display:flex; flex-direction:column; gap:0.01em;}
    .module-card.core { background:#e2eeff; border-color:#3896fa; color:#123470;}
    .module-card.selected { background:#aaf2bc; border-color:#20ba55; color:#14522c;}
    .module-card.disabled { background:#ededed; color:var(--mod-header-grey); cursor:not-allowed; border-style:dashed;}
    .module-card .mod-row {
      display: grid;
      grid-template-columns: minmax(0,1.02fr) minmax(0,1fr) minmax(0,1.1fr);
      align-items: center;
      margin-bottom: 0;
      width: 100%;
      gap: 0.26em;
      min-height: 1.3em;
      white-space: nowrap;
    }
    .module-card .code {
      font-size:0.89em;
      font-weight:bold;
      color: var(--mod-header-color);
      min-width:44px;
      margin-right:0.33em;
      align-self: center;
      white-space:nowrap;
    }
    .module-card .mod-type {
      font-size:0.78em;
      color: var(--mod-header-color);
      opacity: 0.70;
      text-transform:capitalize;
      margin-right:0.36em;
      font-weight: 500;
      letter-spacing:0.01em;
      align-self: center;
    }
    .module-card .credit {
      font-size:0.81em;
      font-weight:400;
      color: var(--mod-header-color);
      opacity:0.85;
      justify-self:end;
      text-align: right;
      white-space:nowrap;
      overflow:visible;
    }
    .split-credit { 
      font-size:0.73em; 
      vertical-align:super; 
      line-height:1; 
      color: var(--mod-header-color);
      font-weight:400;
      margin-left:2px;
      margin-right:1px;
    }
    .module-card.disabled .mod-type,
    .module-card.disabled .code,
    .module-card.disabled .credit {
      color: var(--mod-header-grey);
      opacity: 1;
    }
    .module-card.disabled .credit .split-credit {
      color: var(--mod-header-grey) !important;
    }
    .module-card .mod-title {
      font-size:0.85em;
      font-weight:400;
      color: var(--mod-title-color);
      line-height:1.13;
      margin:0;
      word-break:break-word;
      margin-top:2px;
    }
    .module-card.disabled .mod-title {
      color: var(--mod-title-grey);
    }
    .warning { background:#e5f3ff; color:#23577e; padding:0.43em 0.9em; border-radius:0.47em; margin-bottom:0.7em; border:1px solid #b1d3e6; font-size:1em; display:inline-block; }
    .status-bar { background:#f2f6ff; border-radius:0.26em; padding:0.37em 0.48em; font-size:0.93em; color:#234; display:inline-block;}
    .current-selection { background:#f8f9fd; border-radius:0.4em; padding:0.5em 0.6em 0.37em 0.6em; box-shadow:0 1px 2px #0001; margin-top:0.7em; font-size:0.94em;}
    .current-selection h3 { margin:0 0 0.15em 0; font-size:0.97em; color:#233360; letter-spacing:.2px;}
    .current-selection ul { margin:0 0 0.12em 0; padding-left:1.1em;}
    .current-selection li { font-size:0.93em; margin-bottom:0.03em; color:#222;}
    .csv-error { color: #c00; font-size: 1em; background: #fff5f5; padding: 0.6em; border-radius: 0.3em; margin-bottom: 1em; border: 1px solid #eed;}
    @media (max-width:950px) { .modules-blocks { flex-direction:column; gap:0.4em;} .modules-block { margin-bottom:0.2em;} .top-bar {flex-direction:column; align-items:stretch;} .status-bar {margin-top:0.7em;} }
  </style>
</head>
<body>
  <div class="container">
    <div class="top-bar">
      <div class="dataset-select">
        <select id="dataset">
          <option value="DMCT/Y3-2024-25.csv">Year 3: current 2024-25 options</option>
          <option value="DMCT/Y3+MA2013.csv">Year 3: with MA2013 Interface Narr' added</option>
          <option value="DMCT/Y3+MA2806.csv">Year 3: with MA2806 Data Vis' added</option>
          <option value="DMCT/Y3+CDP.csv">Year 3: MA3020 CDP as 15 credits</option>
          <option value="DMCT/Y3-minusPromo2.csv">Year 3: Minus Promo2 CDP@15 credits</option>
          <option value="DMCT/Y2-2024-25.csv">Year 2: current 2024-25 options</option>
          <option value="DMCT/Y2-swap-MA2013-MA2806.csv">Year 2: MA2013 Interface Narr' Core'</option>
          <option value="DMCT/Y2-MA2013.csv">Year 2: Minus MA2013 Interface Narr'</option>
          <option value="DMCT/Y2-MA2806.csv">Year 2: Minus MA2806 Data Vis'</option>
          <option value="DMCT/Y1.csv">Year 1: All Core Modules</option>
        </select>
      </div>
      <div class="status-bar" id="status-bar"></div>
    </div>
    <div id="csv-error"></div>
    <div id="warnings"></div>
    <div class="modules-blocks">
      <div class="modules-block">
        <div class="block-title">Autumn + Spring</div>
        <div class="module-list" id="autumnspring-list"></div>
      </div>
      <div class="modules-block">
        <div class="block-title">Autumn Only</div>
        <div class="module-list" id="autumn-list"></div>
      </div>
      <div class="modules-block">
        <div class="block-title">Spring Only</div>
        <div class="module-list" id="spring-list"></div>
      </div>
    </div>
    <div class="current-selection" id="current-selection"></div>
  </div>
  <script>
    let selectorInstance = null;

    async function loadModulesFromFile(csvFile) {
      document.getElementById('csv-error').textContent = '';
      try {
        const resp = await fetch(csvFile);
        if (!resp.ok) throw new Error(`Could not load ${csvFile}: ${resp.statusText}`);
        const csvData = await resp.text();
        if (selectorInstance) selectorInstance.destroy();
        const modules = parseCSV(csvData);
        selectorInstance = new ModuleSelector(modules);
      } catch (err) {
        document.getElementById('csv-error').textContent = err.message;
        document.getElementById('status-bar').innerHTML = '';
      }
    }

    // Permalink helpers
    function setDatasetInURL(value) {
      const url = new URL(window.location);
      url.searchParams.set('dataset', value);
      window.history.replaceState({}, '', url);
    }

    function getDatasetFromURL(defaultValue) {
      const params = new URLSearchParams(window.location.search);
      return params.get('dataset') || defaultValue;
    }

    document.addEventListener("DOMContentLoaded", () => {
      const datasetSelect = document.getElementById("dataset");
      // Load from URL if set, otherwise from first option
      const initialValue = getDatasetFromURL(datasetSelect.value);
      datasetSelect.value = initialValue;
      loadModulesFromFile(initialValue);
      datasetSelect.addEventListener("change", (e) => {
        const selectedValue = e.target.value;
        setDatasetInURL(selectedValue);
        loadModulesFromFile(selectedValue);
      });
    });

    function parseCSV(data) {
      const [header, ...rows] = data.trim().split("\n");
      const keys = header.split(",").map(k => k.trim());
      return rows
        .map(row => {
          let vals = [];
          let curr = "", inQuotes = false;
          for (let i = 0; i < row.length; ++i) {
            let ch = row[i];
            if (ch === '"') { inQuotes = !inQuotes; continue; }
            if (ch === "," && !inQuotes) { vals.push(curr.trim()); curr = ""; }
            else curr += ch;
          }
          vals.push(curr.trim());
          let obj = {};
          keys.forEach((k, idx) => obj[k] = (vals[idx] || ""));
          ["exclude", "group"].forEach(key => {
            obj[key] = obj[key]
              ? obj[key].split(/[,/]/).map(s => s.trim()).filter(Boolean)
              : [];
          });
          obj.credits = Number(obj.credits);
          obj.term = obj.term.trim();
          obj.core = obj.core.trim();
          obj.or = obj.or.trim();
          obj.type = obj.type.trim();
          return obj;
        });
    }

    function termsForModule(mod) {
      if (/Autumn\+Spring/i.test(mod.term)) return ["AutumnSpring"];
      if (/Autumn/i.test(mod.term) && !/Spring/i.test(mod.term)) return ["Autumn"];
      if (/Spring/i.test(mod.term) && !/Autumn/i.test(mod.term)) return ["Spring"];
      return [];
    }

    class ModuleSelector {
      constructor(modules) {
        this.modules = modules;
        this.selected = new Set();
        this.creditByTerm = { Autumn: 0, Spring: 0 };
        this.exclusions = {};
        this.groupMap = {};
        this.codeMap = {};

        // Detect "or" groups for core modules
        this.orGroups = this.getOrGroups();
        const codesInOrCore = new Set(this.orGroups.flat().filter(code =>
          this.modules.find(m => m.code === code && m.core === 'core')
        ));

        // Only select non-mutually-exclusive core modules by default
        modules.forEach(m => {
          this.codeMap[m.code] = m;
          m.exclude.forEach(e => {
            this.exclusions[m.code] = this.exclusions[m.code] || [];
            this.exclusions[m.code].push(e);
          });
          m.group.forEach(g => {
            this.groupMap[m.code] = this.groupMap[m.code] || [];
            this.groupMap[m.code].push(g);
          });
          // Only select as default if core and NOT part of any mutually exclusive group
          if (m.core === 'core' && !codesInOrCore.has(m.code)) {
            this.selectModule(m.code);
          }
        });

        this.statusBar = document.getElementById("status-bar");
        this.warnings = document.getElementById("warnings");
        this.autumnSpringList = document.getElementById("autumnspring-list");
        this.autumnList = document.getElementById("autumn-list");
        this.springList = document.getElementById("spring-list");
        this.selectedList = document.getElementById("current-selection");

        this.renderGrid();
        this.updateStatus();
        this.updateSelectedList();
      }

      destroy() {
        this.statusBar.innerHTML = '';
        this.warnings.innerHTML = '';
        this.autumnSpringList.innerHTML = '';
        this.autumnList.innerHTML = '';
        this.springList.innerHTML = '';
        this.selectedList.innerHTML = '';
      }

      getOrGroups() {
        let groups = {};
        this.modules.forEach(m => {
          if (m.or) {
            const ids = m.or.split("/").map(s => s.trim());
            if (ids.length > 1) groups[m.or] = ids;
          }
        });
        return Object.values(groups);
      }

      requireOrCoreSelection() {
        // Require at least one selection in every mutually exclusive group that contains a 'core' module
        for (let group of this.orGroups) {
          if (group.some(code => this.codeMap[code].core === "core")) {
            if (!group.some(code => this.selected.has(code))) return group;
          }
        }
        return null;
      }

      canSelect(module) {
        if (this.selected.has(module.code)) return true;
        const requiredOr = this.requireOrCoreSelection();
        // Only allow picking core 'or' modules if none has been selected yet
        if (requiredOr && !requiredOr.includes(module.code)) return false;
        for (let sel of this.selected) {
          const selMod = this.codeMap[sel];
          if (selMod.exclude.includes(module.code) || module.exclude.includes(sel)) return false;
        }
        let candidateCodes = this.findGroupMembers(module.code).filter(c => !this.selected.has(c));
        let candidateModules = candidateCodes.map(code => this.codeMap[code]);
        let tempCredit = { ...this.creditByTerm };
        for (const m of candidateModules) {
          let tFor = [];
          if (/Autumn\+Spring/i.test(m.term)) tFor = ["Autumn", "Spring"];
          else if (/Autumn/i.test(m.term) && !/Spring/i.test(m.term)) tFor = ["Autumn"];
          else if (/Spring/i.test(m.term) && !/Autumn/i.test(m.term)) tFor = ["Spring"];
          tFor.forEach(term => {
            tempCredit[term] = (tempCredit[term] || 0) + m.credits / tFor.length;
          });
        }
        if (tempCredit.Autumn > 60 || tempCredit.Spring > 60) return false;
        return true;
      }

      findGroupMembers(code) {
        const groupCodes = new Set([code]);
        const thisMod = this.codeMap[code];
        thisMod.group.forEach(g => groupCodes.add(g));
        this.modules.forEach(m => {
          if (m.group.includes(code)) groupCodes.add(m.code);
        });
        return Array.from(groupCodes);
      }

      handleModuleClick(module, e) {
  e.preventDefault();
  // If the module is greyed out/disabled and not already selected, don't allow selection
  if (!this.selected.has(module.code) && !this.canSelect(module)) return;
  // If already selected and is a core, ignore deselection (unless part of a mutually exclusive "or" group—handled in selectModule)
  if (this.selected.has(module.code)) {
    if (module.core === "core") return;
    this.deselectModule(module.code, true);
  } else {
    this.selectModule(module.code, true);
  }
  this.updateStatus();
  this.updateSelectedList();
  this.renderGrid();
}

      selectModule(code, recurse = false) {
        if (this.selected.has(code)) return;
        const allGroupMembers = this.findGroupMembers(code);
        allGroupMembers.forEach(c => {
          if (!this.selected.has(c)) {
            if (c !== code) this.selectModule(c, true);
            else {
              const mod = this.codeMap[c];
              this.selected.add(c);
              let tFor = [];
              if (/Autumn\+Spring/i.test(mod.term)) tFor = ["Autumn", "Spring"];
              else if (/Autumn/i.test(mod.term) && !/Spring/i.test(mod.term)) tFor = ["Autumn"];
              else if (/Spring/i.test(mod.term) && !/Autumn/i.test(mod.term)) tFor = ["Spring"];
              tFor.forEach(term => {
                this.creditByTerm[term] = (this.creditByTerm[term] || 0) + mod.credits / tFor.length;
              });
            }
          }
        });
        for (let group of this.orGroups) {
          if (group.includes(code)) {
            group.forEach(other => { if (other !== code) this.deselectModule(other); });
          }
        }
      }

      deselectModule(code, recurse = false) {
        if (!this.selected.has(code)) return;
        const allGroupMembers = this.findGroupMembers(code);
        allGroupMembers.forEach(c => {
          if (this.selected.has(c)) {
            if (c !== code) this.deselectModule(c, true);
            else {
              const mod = this.codeMap[c];
              this.selected.delete(c);
              let tFor = [];
              if (/Autumn\+Spring/i.test(mod.term)) tFor = ["Autumn", "Spring"];
              else if (/Autumn/i.test(mod.term) && !/Spring/i.test(mod.term)) tFor = ["Autumn"];
              else if (/Spring/i.test(mod.term) && !/Autumn/i.test(mod.term)) tFor = ["Spring"];
              tFor.forEach(term => {
                this.creditByTerm[term] -= mod.credits / tFor.length;
              });
            }
          }
        });
      }

      renderGrid() {
        this.autumnSpringList.innerHTML = "";
        this.autumnList.innerHTML = "";
        this.springList.innerHTML = "";

        const createCard = module => {
          const isAutumnSpring = /Autumn\+Spring/i.test(module.term);
          const creditLabel = isAutumnSpring
            ? `${module.credits}<sup class="split-credit">(${module.credits/2}+${module.credits/2})</sup> credit`
            : `${module.credits} credit`;
          const card = document.createElement("div");
          card.className = "module-card";
          if (this.selected.has(module.code)) {
            card.classList.add("selected");
          } else if (module.core === 'core') {
            card.classList.add("core");
          }
          if (!this.canSelect(module) && !this.selected.has(module.code)) card.classList.add("disabled");

          card.innerHTML = `
            <div class="mod-row">
              <span class="code">${module.code}</span>
              <span class="mod-type">${module.type}</span>
              <span class="credit">${creditLabel}</span>
            </div>
            <div class="mod-title">${module.name}</div>
          `;
          card.addEventListener("click", this.handleModuleClick.bind(this, module));
          return card;
        };

        this.modules.forEach(module => {
          const terms = termsForModule(module);
          if (terms.includes("AutumnSpring")) this.autumnSpringList.appendChild(createCard(module));
          if (terms.includes("Autumn")) this.autumnList.appendChild(createCard(module));
          if (terms.includes("Spring")) this.springList.appendChild(createCard(module));
        });
      }

      updateStatus() {
        let statusMsg = `
          <b>Autumn:</b> ${this.creditByTerm.Autumn || 0}/60 credits &nbsp; | &nbsp;
          <b>Spring:</b> ${this.creditByTerm.Spring || 0}/60 credits
        `;
        const requiredOr = this.requireOrCoreSelection();
        this.warnings.innerHTML = "";
        if (requiredOr) {
          this.warnings.innerHTML = `<div class="warning">Please select one of: <b>${requiredOr.map(code => this.codeMap[code].name).join(" or ")}</b> to continue.</div>`;
        } else if ((this.creditByTerm.Autumn || 0) > 60 || (this.creditByTerm.Spring || 0) > 60) {
          this.warnings.innerHTML = `<div class="warning">Credit limit exceeded! Max 60 credits per term.</div>`;
        }
        this.statusBar.innerHTML = statusMsg;
      }

      updateSelectedList() {
        let html = "<h3>Current Selection</h3>";
        if (!this.selected.size) {
          html += "<div>No modules selected.</div>";
        } else {
          html += "<ul>";
          Array.from(this.selected)
            .map(code => this.codeMap[code])
            .sort((a, b) => a.term.localeCompare(b.term) || a.name.localeCompare(b.name))
            .forEach(m => {
              html += `<li>${m.type.charAt(0).toUpperCase() + m.type.slice(1)} - ${m.name} (${m.code}) - ${m.credits} credit, ${m.term}</li>`;
            });
          html += "</ul>";
        }
        this.selectedList.innerHTML = html;
      }
    }
  </script>
</body>
</html>
